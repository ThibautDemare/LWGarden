{"getTimestamp": {"description": "Renvoie l'horodatage du combat, \u00e9gal au nombre de secondes depuis le 1er janvier 1970.\n\n", "primary": {"Retour": " - **timestamp** : L'horodatage du combat.\n\n"}, "secondary": {"Exemples": "```leekscript\nvar timestamp = getTimestamp()\ndebug(\"Horodatage du combat : \" + timestamp)\n```\n\n", "Voir aussi": " - [[getTime]]\n - [[getDate]]"}}, "getTime": {"description": "Renvoie le temps du d\u00e9but du combat, au format `HH:mm:ss`.\n\n", "primary": {"Retour": " - **time** : Le temps du combat.\n \n"}, "secondary": {"Exemples": "```leekscript\nvar time = getTime()\ndebug(\"Temps du combat : \" + time)\n```\n \n", "Voir aussi": "- [[getDate]]\n- [[getTimestamp]]"}}, "hypot": {"description": "Renvoie l'hypot\u00e9nuse du triangle rectangle de c\u00f4t\u00e9s **x** et **y**.\n\u00c9quivaut \u00e0 `sqrt(x ** 2 + y ** 2)`.\n\n", "primary": {"Param\u00e8tres": "- **x** La valeur x.\n- **y** La valeur y.\n\n", "Retour": "- hypotenuse : sqrt(x**2 + y**2).\n\n"}, "secondary": {"Exemples": "`hypot(1, 1) // sqrt(2)`\n`hypot(3, 4) // 5`\n\n", "Voir aussi": "- [[pow]]\n- [[cos]]\n- [[sin]]"}}, "getEffects": {"description": "Retourne la liste des effets de l'entit\u00e9 d'id **entity**. Pour r\u00e9cup\u00e9rer directement la liste des effets de votre entit\u00e9, utilisez [[getEffects]] sans param\u00e8tre.\n\n", "primary": {"Param\u00e8tres": " - **entity** : L'id de l'entit\u00e9 dont la liste des effets sera retourn\u00e9.\n\n", "Retour": " - **effects** : La liste des effets actuellement pr\u00e9sents sur l'entit\u00e9 **entity**. La liste des effets est un tableau contenant les effets. Un effet est lui-m\u00eame un tableau de 8 cases de la forme : \n```\n [type, value, caster_id, turns, critical, item_id, target_id, modifiers]\n```\n - *type* est le type de l'effet parmi :\n\t - [[EFFECT_DAMAGE]], **value** est le nombre de d\u00e9g\u00e2ts\n\t - [[EFFECT_HEAL]], **value** est le nombre de PV soign\u00e9s\n\t - [[EFFECT_BUFF_STRENGTH]], **value** est la force gagn\u00e9e\n\t - [[EFFECT_BUFF_AGILITY]], **value** est l'agilit\u00e9 gagn\u00e9e\n\t - [[EFFECT_BUFF_TP]], **value** est le nombre de PT gagn\u00e9s\n\t - [[EFFECT_BUFF_MP]], **value** est le nombre de PM gagn\u00e9s\n\t - [[EFFECT_ABSOLUTE_SHIELD]], **value** est le bouclier absolu gagn\u00e9\n\t - [[EFFECT_RELATIVE_SHIELD]], **value** est le bouclier relatif gagn\u00e9\n\t - [[EFFECT_DEBUFF]], indique un d\u00e9buff, **value** est le pourcentage d'effets retir\u00e9.\netc.\n - *value* : La valeur de l'effet.\n - *caster_id* : L'id de l'entit\u00e9 qui a lanc\u00e9 l'effet.\n - *turns* : Le nombre de tours restants de l'effet.\n - *critical* : Est-ce que l'effet est un coup critique.\n - *item_id* : L'id de l'item qui a provoqu\u00e9 cet effet.\n - *target_id* : L'id de la cible de l'effet (**entity**).\n - *modifiers* : Les modificateurs de l'effet (masque de bits avec les constantes **EFFECT_MODIFIER_***)."}, "secondary": []}, "typeOf": {"description": "Renvoie le type de la valeur **value**, parmis les types :\n  - [[TYPE_NULL]] pour une valeur `null`.\n  - [[TYPE_BOOLEAN]] pour un bool\u00e9en, `true` ou `false`.\n  - [[TYPE_NUMBER]] pour un nombre, exemple : `12`, `-0.15`.\n  - [[TYPE_STRING]] pour une cha\u00eene de caract\u00e8res, exemple : `\"salut\"`.\n  - [[TYPE_ARRAY]] pour un tableau, exemple : `[1, 2, 3]`.\n  - [[TYPE_OBJECT]] pour un objet, exemple : `{a: 5, b: true}`.\n  - [[TYPE_CLASS]] pour une classe, exemple : `class A { }`.\n  - [[TYPE_FUNCTION]] pour une fonction, exemple : `function() {}`.\n\n", "primary": {"Param\u00e8tres": "  - **value** : La valeur dont le type sera retourn\u00e9.\n\n", "Retour": "  - **type** : (nombre) Le type de **value**.\n"}, "secondary": []}, "arrayFilter": {"description": "Retourne un nouveau tableau contenant toutes les valeurs du tableau source pour lesquels la fonction callback a renvoy\u00e9 *true*.\n\nSi la fonction callback prend un param\u00e8tre, c'est la valeur du tableau source qui sera envoy\u00e9e, si elle prend deux param\u00e8tres c'est la cl\u00e9 et la valeur qui seront envoy\u00e9es.\n\n", "primary": {"Param\u00e8tres": "- **array** Tableau d'origine.\n- **callback** Fonction appel\u00e9e pour chaque \u00e9l\u00e9ment.\n\n", "Retour": "- **newArray** Nouveau tableau filtr\u00e9.\n\n"}, "secondary": {"Note": "- En **LeekScript V1**, des valeurs **null** sont laiss\u00e9es \u00e0 la place des valeurs retir\u00e9es.\n\n", "Exemples": "```leekscript\nvar array = [1, 2, 3, 4, 5]\nvar result = arrayFilter(array, function(v) {\n    return v % 2 === 0\n})\n// [2, 4]\n```\n```leekscript\nvar array = [10: 'a', 20: 'b', 30: 'c']\nvar result = arrayFilter(array, function(k, v) {\n    return k >= 20\n})\n// ['b', 'c']\n```"}}, "abs": {"description": "Renvoie la valeur absolue du nombre **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** : Le nombre dont la valeur absolue sera calcul\u00e9e.\n\n", "Retour": "- **result** : La valeur absolue du nombre.\n\n"}, "secondary": {"Notes": "L'expression `abs(x)` est \u00e9quivalente \u00e0 `x > 0 ? x : -x`.\n\n", "Exemples": "- Enlever le signe d'un nombre :\n```leekscript\nvar a = -12\nvar a_sans_signe = abs(a)\ndebug(a_sans_signe) // 12\n```\n\n- Calculer la distance entre deux nombres :\n```leekscript\nvar a = 12\nvar b = -5\nvar distance = abs(a - b)\ndebug(distance) // 17\n```\n\n"}}, "lineOfSight": {"description": "V\u00e9rifie la ligne de vue entre la cellule **start** et la cellule **end**, en ignorant les entit\u00e9es and le tableau **entityToIgnore**.<br><br>\n\nL'algorithme se d\u00e9crit comme suit :\n- Tracer un segment entre les centres des deux cellules test\u00e9es.\n- Faire la liste des cellules travers\u00e9es par ce segment. Une cellule n'est pas consid\u00e9r\u00e9e comme travers\u00e9e si le segment fr\u00f4le son bord, ou bien si elle est ignor\u00e9e.\n- Si une seule de ces cellules travers\u00e9e est un obstacle ou contient une entit\u00e9, la ligne de vue est bloqu\u00e9e, sinon elle est d\u00e9gag\u00e9e.\n\nVoir la d\u00e9monstration sur cette page : https://leekwars.com/help/line-of-sight.\n\n", "primary": {"Param\u00e8tres": "  - **start** : Cellule de d\u00e9part.\n  - **end** : Cellule cible.\n  - **entityToIgnore** (optionnel) : Entit\u00e9 \u00e0 ignorer ou tableau d'entit\u00e9es \u00e0 ignorer, par d\u00e9faut, votre entit\u00e9 est ignor\u00e9e.\n\n", "Retour": "  - **los** : (bool\u00e9en)\n    - `true` si la ligne de vue est d\u00e9gag\u00e9e ;\n    - `false` sinon."}, "secondary": []}, "getAlliedTurret": {"description": "Retourne l'id de la tourelle de votre \u00e9quipe ou **null** si elle n'existe pas.\n\n", "primary": {"Retour": "- alliedTurret : L'id de la tourelle de votre \u00e9quipe."}, "secondary": []}, "getEnemyTurret": {"description": "Retourne l'id de la tourelle ennemie ou **null** si elle n'existe pas.\n\n", "primary": {"Retour": " - enemyTurret : L'id de la tourelle ennemie.\n"}, "secondary": []}, "getPath": {"description": "Renvoie le chemin en \u00e9vitant les obstacles entre deux cellules <b>cell1</b> et <b>cell2</b>, si celui-ci existe, en ignorant les cellules contenues dans le tableau <b>ignoredCells</b>.\n\nLa cellule de d\u00e9part <b>cell1</b> ne fait jamais partie du chemin r\u00e9sultant. La cellule <b>cell2</b> fait partie du chemin r\u00e9sultant si et seulement si elle est vide.\n\nSi aucun chemin n'existe entre les deux cellules, <b>getPath</b> renvoie <i>null</i>.\n\nAttention, il est possible que `getPath(cell1, cell2) !== getPath(cell2, cell1)`.\n\t\n", "primary": {"Param\u00e8tres": " - **start** : La cellule de d\u00e9part.\n - **end** : La cellule d'arriv\u00e9e.\n - **ignoredCells** : Le tableau des cellules \u00e0 ignorer.\n\n", "Retour": " - **path**\n \t- Si un chemin existe : un tableau contenant les cellules constituant le chemin entre les deux cellules\n\t- Si le chemin n'a pas \u00e9t\u00e9 trouv\u00e9 : *null*.\n\t\n"}, "secondary": {"Exemples": "```\nvar path = getPath(getCell(), getCell(enemy))\nmark(path, COLOR_RED) // Affiche le chemin entre moi et l'ennemi\n```\n\t\n", "Voir aussi": "- [[getCellDistance]]\n- [[getPathLength]]\n- [[getDistance]]"}}, "arrayConcat": {"description": "Retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments des tableaux pass\u00e9s en param\u00e8tre bout \u00e0 bout. Les cl\u00e9s textuelles sont conserv\u00e9es et toutes les cl\u00e9s num\u00e9riques sont r\u00e9index\u00e9es.\n\n", "primary": {"Param\u00e8tres": "- **array1** : Premier tableau.\n- **array2** : Second tableau.\n\n", "Retour": "- **newArray** : Somme des deux tableaux.\n\n"}, "secondary": {"Exemples": "```\nvar tableau1 = [1, 2]\nvar tableau2 = [3, 4]\ndebug(arrayConcat(tableau1, tableau2)) // [1, 2, 3, 4]\n```"}}, "subArray": {"description": "Retourne un sous-tableau de <b>array</b> commen\u00e7ant \u00e0 la position <b>start</b> et finissant \u00e0 la position <b>end</b>.\n\n", "primary": {"Param\u00e8tres": "- **array** : Tableau source.\n- **start** : Position de d\u00e9part.\n- **end** : Position de fin.\n\n", "Retour": "- **newArray** : Le sous-tableau.\n\n"}, "secondary": {"Exemples": "```\nvar tableau = [0, 1, 2, 3, 4, 5]\ndebug(subArray(tableau, 2, 4)) // [2, 3, 4]\n```\n\nAvec un tableau associatif :\n```\nvar tableauAssoc = [2: 0, 3: 1, 4: 2, 5: 3, 6: 4, 7: 5]\ndebug(subArray(tableauAssoc, 2, 4)) // [2, 3, 4] et non [0, 1, 2]\n```"}}, "log10": {"description": "Calcule le logarithme en base 10 du nombre **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** Un nombre compris dans l'intervalle ]0; +\u221e[.\n\n", "Retour": "- **log10**\n  - Si **number** > 0, le logarithme en base 10 de **number**.\n  - Si **number** <= 0, renvoie `NaN`.\n\n"}, "secondary": {"Exemples": "`log10(1) // 0`\n`log10(10) // 1`\n`log10(1000000) // 6`"}}, "getCellDistance": {"description": "Retourne la distance entre deux cellules **cell1** et **cell2**.<br>\nLa distance retourn\u00e9e est exprim\u00e9e en nombre de cellules, et ne tient pas compte des divers obstacles entre les deux cellules.<br>\nPour obtenir la distance \u00e0 vol d'oiseau, voir [[getDistance]] et pour obtenir la distance du chemin entre les deux cellules en \u00e9vitant les obstacles, voir [[getPathLength]].\n\n", "primary": {"Param\u00e8tres": " - **cell1** : L'id de la cellule de d\u00e9part.\n - **cell2** : L'id de la cellule d'arriv\u00e9e.\n\n", "Retour": " - **distance**\n   - Si les deux cellules sont valides : La distance entre les deux cellules cell1 et cell2.\n   - Si une cellule est invalide, `-1`.\n"}, "secondary": []}, "atan": {"description": "Calcule l'arc tangente d'argument, dans l'intervalle [0, [[PI]]].\n\n", "primary": {"Param\u00e8tres": "- **argument** Nombre dont l'arc tangente sera calcul\u00e9e.\n\n", "Retour": "**result** L'arc tangente d'argument.\n\n"}, "secondary": {"Exemples": "`atan(0) // 0`\n`atan(sqrt(3) / 3) // PI / 6`\n`atan(1) // PI / 4`\n`atan(-1) // -PI / 4`"}}, "cos": {"description": "Calcule le cosinus de **angle**.\n\n", "primary": {"Param\u00e8tres": "- **angle** Nombre dont le cosinus sera calcul\u00e9 (en radians).\n\n", "Retour": "- **cosine** Le cosinus de angle, dans l'intervalle [-1, 1].\n\n"}, "secondary": {"Exemples": "`cos(0) // 1`\n`cos(PI / 2) // 0`\n`cos(PI / 3) // 0.5`\n`cos(PI / 6) // sqrt(3) / 2`"}}, "count": {"description": "Calcule le nombre d'\u00e9l\u00e9ments contenus dans le tableau **array**.<br>\n\n", "primary": {"Param\u00e8tres": "  - **array** : Tableau dont on veut calculer la taille.\n\n", "Retour": "  - **numberOfElements** : (nombre entier) Taille du tableau.\n    - Si le tableau est vide, renvoie `0`.\n\n"}, "secondary": {"Exemples": "```\nvar array = [10, 15.5, 16, 18, 13]\ndebug(\"count = \" + count(array)) // Affiche 5\n```"}}, "randFloat": {"description": "Renvoie un nombre al\u00e9atoire r\u00e9el, compris entre **a** (inclus) et **b** (exclu).\n\n", "primary": {"Param\u00e8tres": "- **a** Borne inf\u00e9rieure.\n- **b** Borne sup\u00e9rieure.\n\n", "Retour": "- **number** Un nombre al\u00e9atoire dans l'intervalle [a; b[.\n\n"}, "secondary": {"Exemples": "`randFloat(10, 20) // 17.551965161250713`\n`randFloat(1000, 2000) // 1610.705920097898`\n\n", "Voir aussi": "- [[rand]]\n- [[randInt]]"}}, "endsWith": {"description": "D\u00e9termine si une cha\u00eene **string** se termine par une cha\u00eene **suffix**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene dans laquelle la recherche sera effectu\u00e9e.\n- **suffix** Suffixe \u00e0 rechercher.\n\n", "Retour": "- **endsWith** true si **string** se termine par **suffix**.\n\n"}, "secondary": {"Exemples": "`endsWith(\"Bonjour\", \"jour\") // true`\n`endsWith(\"Bonjour\", \"Bon\") // false`\n"}}, "arrayFlatten": {"description": "Retourne un nouveau tableau contenant tous les \u00e9l\u00e9ments du tableau source. Tous les \u00e9l\u00e9ments contenus dans un sous tableau sont extraits dans le nouveau tableau.\n\n", "primary": {"Param\u00e8tres": "- **array** : Tableau d'origine.\n\n", "Retour": "- **newArray** : Nouveau tableau.\n\n"}, "secondary": {"Exemples": "```\nvar tableau = [1, 2, [3, 4], 5, [6]]\ndebug(arrayFlatten(tableau)) // [1, 2, 3, 4, 5, 6]\n```"}}, "randInt": {"description": "Renvoie un nombre al\u00e9atoire entier, compris entre **a** (inclus) et **b** (exclu).\n\n", "primary": {"Param\u00e8tres": "- **a** Borne inf\u00e9rieure.\n- **b** Borne sup\u00e9rieure.\n\n", "Retour": "- **number** Un nombre entier al\u00e9atoire dans l'intervalle [**a**; **b**[.\n\n"}, "secondary": {"Exemples": "`randInt(10, 20) // 14`\n`randInt(1000, 2000) // 1680`\n\n", "Voir aussi": "- [[rand]]\n- [[randFloat]]"}}, "log": {"description": "Calcule le logarithme n\u00e9perien du nombre **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** Un nombre compris dans l'intervalle ]0; +\u221e[.\n\n", "Retour": "- **log** Le logarithme n\u00e9perien de number.\n\n"}, "secondary": {"Exemples": "`log(1) // 0`\n`log(e) // 1`\n`log(1000000) // 13.815510558`"}}, "round": {"description": "Retourne l'arrondi de **number**.\nVous pouvez trouver l'arrondi \u00e0 l'entier inf\u00e9rieur avec [[floor]], et l'arrondi \u00e0 l'entier sup\u00e9rieur avec [[ceil]].\n\n", "primary": {"Param\u00e8tres": "- **number** Nombre dont on veut trouver l'arrondi.\n\n", "Retour": "- **number** Arrondi de number.\n\n"}, "secondary": {"Exemples": "`round(1) // 1`\n`round(1.8) // 2`\n`round(2.3) // 2`\n`round(3.5) // 4`\n`round(-12.79) // -13`\n\n", "Voir aussi": "- [[floor]]\n- [[ceil]]"}}, "average": {"description": "Calcule la moyenne des \u00e9l\u00e9ments contenus dans le tableau **array**.<br>\nLa moyenne est calcul\u00e9e en convertissant chaque \u00e9l\u00e9ment en nombre r\u00e9el, en calculant leur somme et enfin en divisant cette somme par la taille du tableau.\n\n", "primary": {"Param\u00e8tres": "  - **array** : Tableau dont on veut calculer la moyenne.\n\n", "Retour": "  - **averageValue** : (nombre r\u00e9el) Valeur moyenne.\n    - Si le tableau est vide, renvoie `0.0`.\n\n"}, "secondary": {"Exemples": "```\nvar array = [10, 15.5, 16, 18, 13]\ndebug(\"moyenne = \" + average(array)) // Affiche 14.5\n```\n"}}, "signum": {"description": "D\u00e9termine le signe du nombre **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** Le nombre dont le signe sera d\u00e9termin\u00e9.\n\n", "Retour": "- **sign** 1 si le nombre est positif, 0 si le nombre est nul et -1 si le nombre est n\u00e9gatif.\n\n"}, "secondary": {"Exemples": "`signum(0) // 0`\n`signum(50) // 1`\n`signum(-12) // -1`"}}, "sin": {"description": "Calcule le sinus de l'angle **angle** pass\u00e9 en param\u00e8tre.\n\n", "primary": {"Param\u00e8tres": "- **angle** L'angle dont le sinus sera calcul\u00e9.\n\n", "Retour": "- **sine** Retourne le sinus de l'angle angle.\n\n"}, "secondary": {"Exemples": "`sin(0) // 0`\n`sin(PI / 2) // 1`\n`sin(PI / 3) // sqrt(3) / 2`\n`sin(PI / 6) // 0.5`\n\n", "Voir aussi": "- [[cos]]\n- [[acos]]\n- [[tan]]"}}, "sqrt": {"description": "Calcule la racine carr\u00e9e du nombre **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** Nombre dont la racine sera calcul\u00e9e.\n\n", "Retour": "- **root** Racine carr\u00e9e de number.\n\n"}, "secondary": {"Exemples": "`sqrt(1) // 1`\n`sqrt(2) // 1.41421356237`\n`sqrt(4) // 2`\n`sqrt(31329) // 177`\n\n", "Voir aussi": "- [[cbrt]]\n- [[pow]]"}}, "indexOf": {"description": "D\u00e9termine la position de la premi\u00e8re occurrence de la cha\u00eene **search** dans la cha\u00eene **string**.\n\n", "primary": {"Param\u00e8tres": "- **string** La cha\u00eene o\u00f9 la recherche sera effectu\u00e9e.\n- **search** La cha\u00eene \u00e0 rechercher.\n- **start** La position de d\u00e9but de recherche, par d\u00e9faut le d\u00e9but de la cha\u00eene (**0**).\n\n", "Retour": "- **index** La position de la premi\u00e8re occurrence de **search** dans **string**, -1 si la cha\u00eene n'a pas \u00e9t\u00e9 trouv\u00e9e.\n\n"}, "secondary": {"Exemples": "`indexOf(\"Bonjour\", \"jour\") // 3`\n`indexOf(\"Bonjour\", \"zzz\") // -1`\n`indexOf(\"Bonjour tout le monde\", \"on\", 0) // 1`\n`indexOf(\"Bonjour tout le monde\", \"on\", 10) // 17`\n"}}, "tan": {"description": "Calcule la tangente de l'angle **angle** (en radians).\n\n", "primary": {"Param\u00e8tres": "- **angle** Angle en radians.\n\n", "Retour": "- **tangent** Tangente de angle.\n\n"}, "secondary": {"Exemples": "`tan(0) // 0`\n`tan(PI / 6) // sqrt(3) / 3`\n`tan(PI / 4) // 1`\n`tan(-PI / 4) // -1`\n\n", "Voir aussi": "- [[cos]]\n- [[sin]]\n- [[atan]]"}}, "toDegrees": {"description": "Convertit l'angle radians en degr\u00e9s.\n\n", "primary": {"Param\u00e8tres": "- **radians** Valeur en radians\n\n", "Retour": "- **degrees** Angle en degr\u00e9s.\n\n"}, "secondary": {"Exemples": "`toDegrees(0) // 0`\n`toDegrees(PI / 4) // 45`\n`toDegrees(PI / 3) // 60`\n`toDegrees(PI / 2) // 90`\n`toDegrees(PI) // 180`\n`toDegrees(2 * PI) // 360`\n\n", "Voir aussi": "- [[toRadians]]"}}, "include": {"description": "Inclut l'IA localis\u00e9e au chemin **ai** dans l'IA courante.\n\nAttention, la fonction include doit \u00eatre appel\u00e9e uniquement dans le bloc principal, et son param\u00e8tre doit \u00eatre une cha\u00eene \u00e9crite directement dans le code. Pour plus d'informations, voir la section dans le tutoriel : https://leekwars.com/help/tutorial#includes.\n\n- Pour inclure une IA dans un **dossier diff\u00e9rent** :\n```\ninclude(\"dossier/autre/fonctions.leek\")\n```\n\n- Pour remonter dans un **dossier parent** :\n```\ninclude(\"../strategie/attaque.leek\")\n```\n\n- Pour partir du **dossier racine** :\n```\ninclude(\"/principal/item.leek\")\n```\n\n", "primary": {"Param\u00e8tres": "  - **ai** : (cha\u00eene) Le chemin de l'IA \u00e0 inclure.\n\n"}, "secondary": {"Synonymes": "import, require"}}, "toRadians": {"description": "Convertit l'angle **degrees** en radians.\n\n", "primary": {"Param\u00e8tres": "- **degrees** Valeur en degr\u00e9s.\n\n", "Retour": "- **radians** Angle en radians.\n\n"}, "secondary": {"Exemples": "`toRadians(0) // 0`\n`toRadians(45) // PI / 4`\n`toRadians(60) // PI / 3`\n`toRadians(90) // PI / 2`\n`toRadians(180) // PI`\n`toRadians(360) // 2 * PI`\n\n", "Voir aussi": "- [[toDegrees]]"}}, "substring": {"description": "Retourne la sous-cha\u00eene de la cha\u00eene **string** \u00e0 partir du caract\u00e8re \u00e0 l'indice **start** et de taille **length**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene source.\n- **start** Indice du caract\u00e8re de d\u00e9part.\n- **length** Longueur de la sous-cha\u00eene.\n\n", "Retour": "- **string** Sous-cha\u00eene.\n\n"}, "secondary": {"Exemples": "`substring(\"Bonjour\", 3) // \"jour\"`\n`substring(\"Bonjour tout le monde\", 3, 9) // \"jour tout\"`"}}, "number": {"description": "Convertit une valeur en nombre. Si la valeur est une cha\u00eene, la fonction number va essayer de la convertir en nombre, si la valeur est d\u00e9j\u00e0 un nombre, la fonction renvoie le nombre, et pour tout autre type, elle renvoie null.\n\n", "primary": {"Param\u00e8tres": "- **value** La valeur \u00e0 convertir en nombre.\n\n", "Retour": "- **number** Le nombre converti.\n\n"}, "secondary": {"Exemples": "`number(\"12345\") // 12345`\n`number(\"3.14159\") // 3.14159`\n`number(\"bonjour\") // null`\n\n", "Voir aussi": "- [[string]]"}}, "startsWith": {"description": "V\u00e9rifie si la cha\u00eene **string** commence par la cha\u00eene **prefix**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene de recherche.\n- **prefix** Pr\u00e9fixe recherch\u00e9.\n\n", "Retour": "- **startsWith** Vrai si la **string** commence par **prefix**.\n\n"}, "secondary": {"Exemples": "`startsWith(\"Bonjour\", \"Bon\") // true`\n`startsWith(\"Bonjour\", \"Poireau\") // false`"}}, "charAt": {"description": "Retourne le caract\u00e8re de la cha\u00eene **string** situ\u00e9 \u00e0 la position **position**.\nLe premier caract\u00e8re de la cha\u00eene se trouve \u00e0 la position 0.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene dont on veut r\u00e9cup\u00e9rer un caract\u00e8re.\n- **position** Position du caract\u00e8re \u00e0 trouver.\n\n", "Retour": "- **char** cha\u00eene contenant le caract\u00e8re recherch\u00e9, ou une cha\u00eene vide si la position est invalide.\n\n"}, "secondary": {"Exemples": "`charAt(\"Bonjour\", 3) // \"j\"`\n`charAt(\"Bonjour\", 999) // \"\"`"}}, "asin": {"description": "Calcule l'arc sinus d'<b>argument</b>, dans l'intervalle [0, [[PI]]].\n\n", "primary": {"Param\u00e8tres": "- **argument** Nombre dont l'arc sinus sera calcul\u00e9.\n\n", "Retour": "- L'arc sinus d'<b>argument</b>.\n\n"}, "secondary": {"Exemples": "`asin(0) // 0`\n`asin(0.5) // PI / 6`\n`asin(1) // PI / 2`"}}, "atan2": {"description": "Convertit les coordonn\u00e9es cart\u00e9siennes (<b>x</b>, <b>y</b>) en coordonn\u00e9es polaires (<b>r</b>, <b>theta</b>). Cette fonction retourne l'angle <b>theta</b> entre -[[PI]] et [[PI]] en utilisant les signes des arguments.\n\n", "primary": {"Param\u00e8tres": "- **y** Coordonn\u00e9e en y.\n- **x** Coordonn\u00e9e en x.\n\n", "Retour": "- **result** L'angle <b>theta</b> en coordonn\u00e9es polaires du point (x, y).\n\n"}, "secondary": {"Note": "Attention, les arguments sont bien dans l'ordre **Y** puis **X**, ce qui est un peu contre-intuitif.\n\n", "Exemples": "`atan2(1, 1) // PI / 4`\n`atan2(-1, 1) // -PI / 4`\n`atan2(1, -1) // 3 * PI / 4`\n`atan2(-1, -1) // -3 * PI / 4`\n"}}, "rand": {"description": "Renvoie un nombre al\u00e9atoire r\u00e9el, compris entre 0 (inclus) et 1 (exclu), suivant une distribution uniforme.\n\n", "primary": {"Retour": "- **number** Un nombre al\u00e9atoire dans l'intervalle [0; 1[.\n\n"}, "secondary": {"Exemples": "`rand() // 0.0315627088835804`\n`rand() // 0.2746200479206138`\n`rand() // 0.3811411548987587`"}}, "pow": {"description": "\u00c9leve le nombre **base** \u00e0 la puissance exposant.\n\n", "primary": {"Param\u00e8tres": "- **base** La base.\n- **exp** L'exposant.\n\n", "Retour": "- **result** base \u00e9lev\u00e9e \u00e0 la puissance exposant.\n\n"}, "secondary": {"Exemples": "`pow(2, 10) // 1024`\n`pow(10, 6) // 1000000`\n\n", "Voir aussi": "- [[exp]]"}}, "contains": {"description": "D\u00e9termine si une cha\u00eene **search** se trouve dans une cha\u00eene **string**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene dans laquelle la recherche sera effectu\u00e9e.\n- **search** Cha\u00eene \u00e0 rechercher.\n\n", "Retour": "- **contains** true si **search** est dans **string**, false sinon.\n\n"}, "secondary": {"Exemples": "`contains(\"Bonjour\", \"jour\") // true`\n`contains(\"Bonjour\", \"zzz\") // false`"}}, "acos": {"description": "Calcule l'arc cosinus d'<b>argument</b>, dans l'intervalle [0, [[PI]]].\n\n", "primary": {"Param\u00e8tres": "- **argument** Nombre dont l'arc cosinus sera calcul\u00e9.\n\n", "Retour": "- **result** L'arc cosinus d'<b>argument</b>.\n\n"}, "secondary": {"Exemples": "`acos(0) // PI / 2`\n`acos(0.5) // PI / 3`\n`acos(-0.5) // 2 * PI / 3`\n"}}, "cbrt": {"description": "Calcule la racine cubique de **number**.\n\n", "primary": {"Param\u00e8tres": "- **number** Nombre dont on veut calculer la racine cubique.\n\n", "Retour": "- **result** Racine cubique de number.\n\n"}, "secondary": {"Exemples": "`cbrt(1) // 1`\n`cbrt(8) // 2`\n`cbrt(27) // 3`\n`cbrt(125) // 5`\n"}}, "exp": {"description": "\u00c9leve le nombre d'Euler [[E]] \u00e0 la puissance number.\n\n", "primary": {"Param\u00e8tres": "- **number** L'exposant auquel [[E]] sera \u00e9lev\u00e9.\n\n", "Retour": "- **result** : E ** number.\n\n"}, "secondary": {"Exemples": "`exp(0) // 1`\n`exp(1) // E`\n`exp(12) // 162754.791419`"}}, "ceil": {"description": "Retourne l'arrondi \u00e0 l'entier sup\u00e9rieur de **number**.\nVous pouvez trouver l'arrondi \u00e0 l'entier inf\u00e9rieur avec [[floor]], et l'arrondi avec [[round]].\n\n", "primary": {"Param\u00e8tres": "- **number** Nombre dont on veut trouver l'arrondi sup\u00e9rieur.\n\n", "Retour": "- **result** Arrondi \u00e0 l'entier sup\u00e9rieur de number.\n\n"}, "secondary": {"Exemples": "`ceil(1) // 1`\n`ceil(1.8) // 2`\n`ceil(2.3) // 3`\n`ceil(3.5) // 4`\n`ceil(-12.79) // -12`\n"}}, "length": {"description": "Renvoie la longueur de la cha\u00eene **string**.\n\n", "primary": {"Param\u00e8tres": "- **string** La cha\u00eene dont la longueur sera retourn\u00e9e.\n\n", "Retour": "- **length** La longueur de la cha\u00eene **string**.\n\n"}, "secondary": {"Exemples": "`length(\"\") // 0`\n`length(\"a\") // 1`\n`length(\"Bonjour\") // 7`"}}, "replace": {"description": "Remplace toutes les occurrences de **search** par **replace** dans la cha\u00eene **string**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene dans laquelle les remplacements sont effectu\u00e9s.\n- **search** Sous-cha\u00eene \u00e0 remplacer.\n- **replace** Cha\u00eene de remplacement.\n\n", "Retour": "- **string** La cha\u00eene r\u00e9sultat, avec les remplacements.\n\n"}, "secondary": {"Exemples": "`replace(\"Banana\", \"n\", \"t\") // \"Batata\"`\n`replace(\"a,b,c,d,e,f\", \",\", \"+\") // \"a+b+c+d+e+f\"`\n`replace(\"Bonjour tout le monde\", \"Bonjour\", \"Bonsoir\") // \"Bonsoir tout le monde\"`"}}, "split": {"description": "D\u00e9coupe la cha\u00eene **string** sous-cha\u00eenes en d\u00e9limit\u00e9es par **delimiter**. Pour limiter la d\u00e9coupe \u00e0 un certain nombre de morceaux, utilisez le param\u00e8tre **limit**.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene \u00e0 d\u00e9couper.\n- **delimiter** Cha\u00eene d\u00e9limitant le passage d'un \u00e9l\u00e9ment \u00e0 un autre.\n- **limit** (optionnel) Le nombre maximum de sous-cha\u00eenes, par d\u00e9faut, pas de limite.\n\n", "Retour": "- **parts** Tableau contenant les sous-cha\u00eenes trouv\u00e9es.\n\n"}, "secondary": {"Exemples": "`split(\"456-789-123\", \"-\") // [\"456\", \"789\", \"123\"]`\n`split(\"Hello\", \"\") // [\"H\", \"e\", \"l\", \"l\", \"o\"]`\n`split(\"Hello\", \"zzz\") // [\"Hello\"]`\n`split(\"456-789-123\", \"-\", 2) // [\"456\", \"789-123\"]`"}}, "string": {"description": "Convertit une valeur **value** en cha\u00eene de caract\u00e8res.\n\n- Si la valeur est null, `null` est renvoy\u00e9e.\n- Si la valeur est un bool\u00e9en, `true` et `false` sont respectivement renvoy\u00e9es pour les valeurs true et false.\n- Si la valeur est d\u00e9j\u00e0 une cha\u00eene, elle est renvoy\u00e9e.\n- Si la valeur est nombre x, `\"x\"` est renvoy\u00e9.\n- Si la valeur est un tableau, une cha\u00eene sous la forme `[cl\u00e91 : valeur1, cl\u00e92 : valeur2, ...]` est renvoy\u00e9e.\n- Si la valeur est un objet, une cha\u00eene sous la forme `Classe { champ1 : valeur1, champ2 : valeur2, ... }` est renvoy\u00e9e.\n\n\n", "primary": {"Param\u00e8tres": "- **value** La valeur \u00e0 convertir en cha\u00eene de caract\u00e8res.\n\n", "Retour": "- **string** La cha\u00eene convertie.\n\n"}, "secondary": {"Exemples": "`string(12345) // \"12345\"`\n`string([1, 2, 3]) // \"[1, 2, 3]\"`\n`string(\"hello\") // \"hello\"`\n`string(\"true\") // true`"}}, "max": {"description": "Renvoie le plus grande valeur entre les deux nombres **a** et **b**.\n\n", "primary": {"Param\u00e8tres": "- **a** Un nombre.\n- **b** Un nombre.\n\n", "Retour": "- **max** Le plus grand nombre entre **a** et **b**.\n\n"}, "secondary": {"Exemples": "`max(2, 5) // 5`\n`max(-2, -5) // -2`\n\n", "Voir aussi": "- [[min]]"}}, "toLower": {"description": "Convertit les caract\u00e8res majuscules de la cha\u00eene **string** en minuscules.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene \u00e0 transformer\n\n", "Retour": "- **string** Cha\u00eene en minuscules\n\n"}, "secondary": {"Exemples": "`toLower(\"BONJOUR\") // \"bonjour\"`\n`toLower(\"Bonjour\") // \"bonjour\"`\n`toLower(\"hello\") // \"hello\"`"}}, "floor": {"description": "Calcule l'arrondi \u00e0 l'entier inf\u00e9rieur de **number**.\nVous pouvez trouver l'arrondi \u00e0 l'entier sup\u00e9rieur avec [[ceil]], et l'arrondi avec [[round]].\n\n", "primary": {"Param\u00e8tres": "- **number** Nombre dont on veut trouver l'arrondi inf\u00e9rieur.\n\n", "Retour": "- **result** Arrondi \u00e0 l'entier inf\u00e9rieur de number.\n\n"}, "secondary": {"Exemples": "`floor(1) // 1`\n`floor(1.8) // 1`\n`floor(2.3) // 2`\n`floor(3.5) // 3`\n`floor(-12.79) // -13`\n\n", "Voir aussi": "- [[ceil]]\n- [[round]]"}}, "min": {"description": "Renvoie la plus petite valeur entre les deux nombres **a** et **b**.\n\n", "primary": {"Param\u00e8tres": "- **a** Un nombre.\n- **b** Un nombre.\n\n", "Retour": "- **min** Le plus petit nombre entre a et b.\n\n"}, "secondary": {"Exemples": "`max(2, 5) // 2`\n`max(-2, -5) // -5`\n\n", "Voir aussi": "- [[max]]"}}, "toUpper": {"description": "Convertit les caract\u00e8res minuscules de la cha\u00eene **string** en majuscules.\n\n", "primary": {"Param\u00e8tres": "- **string** Cha\u00eene \u00e0 transformer\n\n", "Retour": "- **string** Cha\u00eene en majuscules\n\n"}, "secondary": {"Exemples": "`toUpper(\"bonjour\") // \"BONJOUR\"`\n`toUpper(\"Bonjour\") // \"BONJOUR\"`\n`toUpper(\"HELLO\") // \"HELLO\"`"}}}